##### Code TP4
# Taux de croissance de bactérie à différente température

# Package nls
library(proto)
library(nls2)

# Fonction
# Tmin : température en deça de laquelle il n'y a plus de croissance
# Tmax : température au delà de laquelle il n'y a plus de croissance
# Topt : température pour laquelle le taux de croissance Yopt est maximal
# Yopt : taux de croissance maximal
F = function(t, Tmin, Tmax, Topt, Yopt){
  if( t > Tmin && t < Tmax)
    F = (Yopt*(t-Tmax)*(t-Tmin)^2)/ ((Topt-Tmin)*((Topt-Tmin)*(t-Topt)-(Topt-Tmax)*(Topt+Tmin-2*t)))
  else
    F = 0
}

F2 = function(T,Tmin,Tmax,Topt,Yopt){
Ind = 0*T
Ind[(T >= Tmin)&(T<=Tmax)] = 1
F = Yopt*(T-Tmax)*(T-Tmin)^2 / ((Topt-Tmin)*((Topt-Tmin)*
(T-Topt)-(Topt-Tmax)*(Topt+Tmin-2*T)))*Ind
}

# Données
data = read.table("http://lmi.insa-rouen.fr/~portier/Data/barber.txt", header=TRUE)
attach(data)
summary(data)

jpeg("Nuage de points - Paramètres intiaux.jpeg")
plot(data, main="Nuage de points")
rug(Temperature)

# Conditions intiales
Tmin_ini = 8
Tmax_ini = 50
Topt_ini = 40
Yopt_ini = 2.3
y = NULL
for(t in 1:50){
  y[t]=F(t, Tmin_ini, Tmax_ini, Topt_ini, Yopt_ini)
}
lines(y, col="green", lwd=2)

# Estimation des paramètres du modèle
Y=TauxCroissance
T=Temperature
nlsmod = nls(Y ~ Yopt * (T - Tmax) * (T - Tmin)^2 / ((Topt - Tmin) * ((Topt - Tmin) * (T - Topt) - (Topt - Tmax) * (Topt + Tmin - 2 * T))), start=list(Tmin=Tmin_ini, Tmax=Tmax_ini, Topt=Topt_ini, Yopt=Yopt_ini), trace=FALSE)

# What does this do ?
#fmla <- as.formula(Y ~ Yopt * (T - Tmax) * (T - Tmin)^2 / ((Topt - Tmin) * ((Topt - Tmin) * (T - Topt) - (Topt - Tmax) * (Topt + Tmin - 2 * T))))
#summary(fmla)

# Calcul de l'ajustement
Tmin = summary(nlsmod)$param[1]
Tmax = summary(nlsmod)$param[2]
Topt = summary(nlsmod)$param[3]
Yopt = summary(nlsmod)$param[4]
for(t in 1:50){
  y[t]=F(t, Tmin, Tmax, Topt, Yopt)
}
lines(y, col="red", lwd=2)
dev.off()

# Nuage observé/prévu
jpeg("Nuage observé-prévu.jpeg")
plot(TauxCroissance, predict(nlsmod), xlab="Observé", ylab="Prévu", main="Nuage observé-prévu")
abline(0, 1, lwd=2, col="red")
dev.off()

# rédisus non normalisés
jpeg("Résidus non normalisés.jpeg")
R = residuals(nlsmod)
plot(R)
abline(0, 0, lwd=2, col="red")
dev.off()

# A faire
# Deuxième fonction
resnls = nls(Y~F2(T,Tmin,Tmax,Topt,Yopt),start=c(Tmin=Tmin_ini ,Tmax=Tmax_ini ,Topt=Topt_ini ,Yopt=Yopt_ini))

# Estimation Bootstrap
n = length(Temperature)
B = 1000
rbs = NULL
Ybs = NULL
Tmin_bs = NULL
Tmax_bs = NULL
Topt_bs = NULL
Yopt_bs = NULL
ybs = NULL
for(b in 1:B){
  ind = sample(1:n, n, replace=TRUE)
  rbs = resnls$resid[ind]
  Ybs = F(Temperature, Tmin, Tmax, Topt, Yopt) + rbs
  nlsmod_bs = nls(Ybs ~ F(Temperature, Tmin, Tmax, Topt, Yopt), start=list(Tmin=Tmin_ini, Tmax=Tmax_ini, Topt=Topt_ini, Yopt=Yopt_ini), trace=FALSE)
  # Récupérer les estimations bootstrap et les mettre dans les vecteurs
  ybs[b] = F(Temperature,  Tmin_bs, Tmax_bs, Topt_bs, Yopt_bs)
}
# Distributions bootstrap
par(mfrow=c(2,2))
hist(Tmin_bs, main="Distribution bootstrap de Tmin")
hist(Tmax_bs, main="Distribution bootstrap de Tmax")
hist(Topt_bs, main="Distribution bootstrap de Topt")
hist(Yopt_bs, main="Distribution bootstrap de Yopt")

# Intervalles de confiance
cat('Intervalle de confiance pour Tmin : [', sort(Tmin)[25], ';', sort(Tmin)[975], ']\n')

# Intervalles de prévision
y_inf = sort(ybs[25])
y_sup = sort(ybs[975])
# Afficher l'ajustement
lines(y_inf)
lines(y_sup)

