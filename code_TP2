### Régréssion non linéaire ###
# TP2 : Bootstrap non paramétrique

### Notes ###
# Tirage aléatoire de 20 valeurs entre 0 et 20
sample(1:20, 20)
# Tirage aléatoire de 20 valeurs entre 0 et 20 avec remise
sample(1:20, 20)

### Partie 1 - Acier ###
# On cherche à étudier la résistance à la traction en fonction de la teneur carbonée
# R : résistance de l'acier à la traction
# C : teneur carbonnée
# Téléchargement des données et résumé
carbone = read.table("http://lmi.insa-rouen.fr/~portier/Data/carbone.txt",header=TRUE)
summary(carbone)
attach(carbone)

# 1. Coefficient de corrélation linéaire
cor(C, R)

# 2. Biais de l'erreur standard
n = length(R)
# 2000 
B = 1000
biais = NULL
stde = NULL
est = NULL
for(b in 1:B){
	ind = sample(1:n, n, replace=TRUE)
	biais[b] = cor(C[ind], R[ind]) - cor(C, R)
	stde[b] = cor(C[ind], R[ind])
	est[b] = cor(C, R) - biais[b]
}
# Verifier avec freq probability densité pour ne pas avoir/avoir les effectifs
hist(est, freq=F, breaks=6, xlab="Estimation coefficient de corrélation linéaire par bootstrap", ylab="Fréquence" ,main="Histogramme en fréquence")
boxplot(est)
# Estimateur boostrapé
mean(est)-cor(C, R)
# Erreur standard
sd(est)
# A faire pour plusieurs valeurs de B



### Partie 2 - Tension systolique ###
# On cherche à expliquer la tension systolique par l'age
# T : tension systolique
# A : âge
systolique = read.table("http://lmi.insa-rouen.fr/~portier/Data/systolique.txt",header=TRUE)
summary(systolique)
attach(systolique)

# 1. Etude descriptive des données
# on va utiliser le modèle linéaire gaussien simple
cor(Age, Tension)
model <- lm(Tension ~ Age)
anova(model)
plot(systolique, main="Age en fonction de la tension")
abline(model$coef, col=2, lwd=2)
plot(model$resid, main="Résidus", xlab="Age", ylab="Tension")
abline(0,0,col=2,lwd=2)

# 2. Calcul de prévision
# Méthode des pourcentiles simples (!!! SUR L'AGE ET LA TENSION !!!)
Age_prev = 90 # Age pour lequel on veut la prévision

# Paramètres du modèle
n = length(Age)
a0 = model$coef[1]
a1 = model$coef[2]

# Paramètres bootstrap
B = 1000
rbs = NULL
Ybs = NULL
a0_bs = NULL
a0_biais = NULL # Vecteur des biais bootstrap
a1_bs = NULL
a1_biais = NULL
Y0 = NULL # Vecteur des prévision bootstrap

for(b in 1:B){
	ind = sample(1:n, n, replace=TRUE)
	rbs = model$resid[ind]
	Ybs = a0 + a1 *Age + rbs
	model_bs <- lm(Ybs ~ Age)
	a0_biais[b] = model_bs$coef[1] - a0
	a1_biais[b] = model_bs$coef[2] - a1
	a0_bs[b] = a0 - a0_biais[b]
	a1_bs[b] = a1 - a1_biais[b]
	Y0[b] = a0_bs[b] + a1_bs[b] * Age_prev
}

# Intervalle
borne_inf = sort(Y0)[25]
borne_sup = sort(Y0)[975]
cat('Intervalle de prévision à 95% pour ', Age_prev, 'ans : [ ', borne_inf, ' : ', borne_sup, ' ]\n')

# Méthodes de student
# Utiliser quantile(rnorm(100000,0,1),c(0.025,0.975))


### Partie 3 - Ozone ###
# On cherche à expliquer la concentration en ozone
# T12 : température à 12h
# Ne12 : nébulosité à 12h
# Vx : vent à 12 sur l'axe Est-Ouest
ozone <- read.table('http://lmi.insa-rouen.fr/~portier/Data/ozone.txt', header=TRUE)
summary(ozone)
attach(ozone)
model<-lm(maxO3 ~ T12 + Ne12 +Vx)

# 1. Méthode des pourcentiles simples
cat('Méthode des pourcentiles simples')
# Paramètres du modèle
n = length(max03)
a0 = model$coef[1]
a1 = model$coef[2]
a2 = model$coef[3]
a3 = model$coef[4]

# Paramètres bootstrap
B = 1000
rbs = NULL
Ybs = NULL
a0_bs = NULL
a0_biais = NULL
sd0_bs = NULL
a1_bs = NULL
a1_biais = NULL
sd1_bs = NULL
a2_bs = NULL
a2_biais = NULL
sd2_bs = NULL
a3_bs = NULL
a3_biais = NULL
sd3_bs= NULL

for(b in 1:B){
	ind = sample(1:n, n, replace=TRUE)
	rbs = model$resid[ind]
	Ybs = a0 + a1 * T12 + a2 * Ne12 + a3 * Vx + rbs
	model_bs <- lm(Ybs ~ T12 + Ne12 + Vx)
	a0_bs[b] = model_bs$coef[1]
	a0_bs[b] = model_bs$coef[1]
	a0_bs[b] = model_bs$coef[1]
	#a0_biais[b] = model_bs$coef[1] - a0
	#a1_biais[b] = model_bs$coef[2] - a1
	#a2_biais[b] = model_bs$coef[3] - a2
	#a3_biais[b] = model_bs$coef[4] - a3
	#a0_bs[b] = a0 - a0_biais[b]
	#a1_bs[b] = a1 - a1_biais[b]
	#a2_bs[b] = a2 - a3_biais[b]
	#a3_bs[b] = a3 - a3_biais[b]
	#sd0_bs[b] = sd(a0_bs[b])
	#sd1_bs[b] = sd(a1_bs[b])
	#sd2_bs[b] = sd(a2_bs[b])
	#sd3_bs[b] = sd(a3_bs[b])
}

cat('Intervalle de prévision à 95% pour :
	a0 : [ ', sort(a0_bs)[25], ' : ', sort(a0_bs)[975], ' ]
	a1 : [ ', sort(a1_bs)[25], ' : ', sort(a1_bs)[975], ' ]
	a2 : [ ', sort(a2_bs)[25], ' : ', sort(a2_bs)[975], ' ]
	a3 : [ ', sort(a3_bs)[25], ' : ', sort(a3_bs)[975], ' ]\n')

# 1. Méthode de l'erreur standard
cat('Méthode de l'erreur standard')


